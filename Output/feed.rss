<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>SwiftZone</title><description>A description of SwiftZone</description><link>https://swiftzone.dev</link><language>es</language><lastBuildDate>Tue, 25 Oct 2022 14:43:05 -0400</lastBuildDate><pubDate>Tue, 25 Oct 2022 14:43:05 -0400</pubDate><ttl>250</ttl><atom:link href="https://swiftzone.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://swiftzone.dev/posts/publish-framework</guid><title>Publish Framework</title><description>Publish framework es un generador de sitios estáticos desarrollado por John Sundell y creado específicamente para desarrolladores de Swift. Permite crear sitios web completos con Swift y admite temas, plugins y toneladas de otras opciones de personalización potentes.</description><link>https://swiftzone.dev/posts/publish-framework</link><pubDate>Mon, 6 Dec 2021 07:00:00 -0500</pubDate><content:encoded><![CDATA[<p align="center" margin-top="10px">
    <img src="https://swiftzone.dev/images/blog/PublishLogo.png" width="400" max-width="90%" alt="Publish" />
</p><p>Publish framework es un generador de sitios estáticos desarrollado por John Sundell y creado específicamente para desarrolladores de Swift. Permite crear sitios web completos con Swift y admite temas, plugins y toneladas de otras opciones de personalización potentes.</p><p>Cuando se usa Publish, cada sitio web se define como un paquete Swift, que actúa como la configuración de cómo se debe generar e implementar el sitio web, todo utilizando código Swift nativo y de tipo seguro.</p><h1>Instalación</h1><p>Publish se distribuye utilizando Swift Package Manager. Para instalarlo en un proyecto, agréguelo como una dependencia dentro de su manifiesto Package.swift:</p><pre><code class="language-swift">let package = Package(
    ...
    dependencies: [
        .package(url: "https://github.com/johnsundell/publish.git", from: "0.1.0")
    ],
    ...
)
</code></pre><p>Luego, importe Publish donde quiera usarlo:</p><pre><code class="language-swift">import Publish
</code></pre><p>Publish también incluye una herramienta de línea de comandos que facilita la configuración de nuevos proyectos de sitios web y la generación e implementación de los existentes. Para instalar esa herramienta de línea de comando, simplemente ejecute make dentro de una copia local del repositorio de publicación:</p><pre><code class="language-sh">$ git clone https://github.com/JohnSundell/Publish.git
$ cd Publish
$ make
</code></pre><p>A continuación, ejecute <code>publish help</code> para obtener instrucciones sobre cómo utilizarla.<br></br></p><p>La herramienta de línea de comando Publicar también está disponible a través de Homebrew y se puede instalar usando el siguiente comando si tiene Homebrew instalado:</p><pre><code class="language-sh">brew install publish
</code></pre><h1>Inicio rápido</h1><p>Para comenzar rápidamente con Publish, instale la herramienta de línea de comando clonando primero este repositorio y luego ejecute <code>make</code> dentro de la carpeta clonada:</p><pre><code>$ git clone https://github.com/JohnSundell/Publish.git
$ cd Publish
$ make
</code></pre><p><strong>*Nota</strong>: Si encuentra un error al ejecutar <code>make</code>, asegúrese de tener la ubicación de las herramientas de línea de comandos configurada en las preferencias de Xcode. Está en Preferencias&gt; Ubicaciones&gt; Ubicaciones&gt; Herramientas de línea de comandos. El menú desplegable estará en blanco si aún no se ha configurado._</p><p>Luego, cree una nueva carpeta para su nuevo proyecto de sitio web y simplemente ejecute <code>publish new</code> dentro de ella para comenzar:</p><pre><code class="language-sh">$ mkdir MyWebsite
$ cd MyWebsite
$ publish new
</code></pre><p>Finalmente, ejecute <code>open Package.swift</code> para abrir el proyecto en Xcode y comenzar a construir su nuevo sitio web.</p><h1>Server</h1><p>Para iniciar el servidor de desarrollo ejecute en la raíz del proyecto <code>publish run</code> y le mostrara un mensaje en consola con la url a consultar.</p><h1>Comience de manera simple y personalice cuando sea necesario</h1><p>Cada sitio web creado con Publish puede decidir libremente qué tipo de secciones y metadatos desea admitir. Arriba, agregamos tres secciones: Recetas, Vínculos y Acerca de, que luego pueden contener cualquier cantidad de elementos. También hemos agregado soporte para nuestros propios metadatos de elementos específicos del sitio a través del tipo ItemMetadata, que podremos usar de manera totalmente segura durante todo el proceso de publicación.</p><pre><code class="language-swift">struct DeliciousRecipes: Website {
    enum SectionID: String, WebsiteSectionID {
        case recipes
        case links
        case about
    }

    struct ItemMetadata: WebsiteItemMetadata {
        var ingredients: [String]
        var preparationTime: TimeInterval
    }

    var url = URL(string: "https://cooking-with-john.com")!
    var name = "Delicious Recipes"
    var description = "Many very delicious recipes."
    var language: Language { .english }
    var imagePath: Path? { "images/logo.png" }
}
</code></pre><p>Si bien Publish ofrece una API realmente poderosa que permite personalizar y ajustar casi todos los aspectos del proceso de generación de sitios web, también incluye un conjunto de API de conveniencia que tiene como objetivo hacer que comenzar sea lo más rápido y fácil posible.</p><p>Para comenzar a generar el sitio web de Delicious Recipes que definimos anteriormente, todo lo que necesitamos es una sola línea de código, que le dice a Publish qué tema usar para generar el HTML de nuestro sitio web:</p><pre><code class="language-swift">try DeliciousRecipes().publish(withTheme: .foundation)
</code></pre><p><em>La llamada anterior no solo representa el HTML de nuestro sitio web, sino que también genera una fuente RSS, un mapa del sitio y más.</em></p><p>Anteriormente, usamos el tema básico integrado de Publish, que es un tema muy básico que se proporciona principalmente como punto de partida y como ejemplo de cómo se pueden crear los temas de Publish. Por supuesto, podemos reemplazar ese tema en cualquier momento por uno propio y personalizado, que puede incluir cualquier tipo de HTML y recursos que queramos.</p><p>De forma predeterminada, Publish generará el contenido de un sitio web en función de los archivos Markdown colocados dentro de la carpeta <code>Content</code> de ese proyecto, pero también se puede agregar mediante programación cualquier número de elementos de contenido y páginas personalizadas.</p><p><strong>Publish admite tres tipos de contenido:</strong></p><p><strong>Sections</strong>, que se crean en función de los miembros de la enumeración <code>SectionID</code> de cada sitio web. Cada sección tiene su propia página HTML y también puede actuar como un contenedor para una lista de <strong>Items</strong>, que representan las páginas HTML anidadas dentro de esa sección. Finalmente, <strong>Pages</strong> proporciona una forma de crear páginas personalizadas de formato libre que se pueden colocar en cualquier tipo de jerarquía de carpetas.</p><p>Cada <code>Section</code>, <code>Items</code> y <code>Page</code> puede definir su propio conjunto de Contenido, que puede variar desde texto (como títulos y descripciones) hasta HTML, audio, video y varios tipos de metadatos.</p><p>A continuación, le mostramos cómo podríamos extender nuestra llamada básica <code>publish()</code> desde antes para inyectar nuestra propia canalización de publicación personalizada, lo que nos permite definir nuevos elementos, modificar secciones y mucho más:</p><pre><code class="language-swift">try DeliciousRecipes().publish(
    withTheme: .foundation,
    additionalSteps: [
        // Agrega un item mediante código
        .addItem(Item(
            path: "my-favorite-recipe",
            sectionID: .recipes,
            metadata: DeliciousRecipes.ItemMetadata(
                ingredients: ["Chocolate", "Coffee", "Flour"],
                preparationTime: 10 * 60
            ),
            tags: ["favorite", "featured"],
            content: Content(
                title: "Check out my favorite recipe!"
            )
        )),
        // Agrega titulos por defecto a todas las secciones
        .step(named: "Default section titles") { context in
            context.mutateAllSections { section in
                guard section.title.isEmpty else { return }
                
                switch section.id {
                case .recipes:
                    section.title = "My recipes"
                case .links:
                    section.title = "External links"
                case .about:
                    section.title = "About this site"
                }
            }
        }
    ]
)
</code></pre><p>Por supuesto, definir todo el código de un programa en un solo lugar rara vez es una buena idea, por lo que se recomienda dividir las diversas operaciones de generación de un sitio web en pasos claramente separados, que se pueden definir extendiendo el tipo <code>PublishingStep</code> con propiedades estáticas o métodos, como este:</p><pre><code class="language-swift">extension PublishingStep where Site == DeliciousRecipes {
    static func addDefaultSectionTitles() -&gt; Self {
        .step(named: "Titulo de secciones por defecto") { context in
            context.mutateAllSections { section in
                guard section.title.isEmpty else { return }
                switch section.id {
                case .recipes:
                    section.title = "My recipes"
                case .links:
                    section.title = "External links"
                case .about:
                    section.title = "About this site"
                }
            }
        }
    }
}
</code></pre><p><em>A cada paso de publicación se le pasa una instancia de <code>PublishingContext</code>, que puede usar para mutar el contexto actual en el que se publica el sitio web, incluidos sus archivos, carpetas y contenido.</em></p><p>Con el patrón anterior, podemos implementar cualquier número de pasos de publicación personalizados que se ajusten perfectamente a todos los pasos predeterminados con los que se envía Publish. Esto nos permite construir pipelines realmente poderosos en los que cada paso realiza una sola parte del proceso de generación:</p><pre><code class="language-swift">try DeliciousRecipes().publish(using: [
    .addMarkdownFiles(),
    .copyResources(),
    .addFavoriteItems(),
    .addDefaultSectionTitles(),
    .generateHTML(withTheme: .delicious),
    .generateRSSFeed(including: [.recipes]),
    .generateSiteMap()
])
</code></pre><p><em>Arriba, estamos construyendo una canalización de publicación completamente personalizada llamando a la API <code>publish(using:)</code>.</em></p><p>Para obtener más información sobre los pasos de publicación integrados de Publish,<a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/PublishingStep.swift">mira este archivo</a>.</p><h1>Construyendo un tema HTML</h1><p>Publish utiliza [Plot] (https://github.com/johnsundell/plot) como motor de creación de temas HTML, que permite definir páginas HTML completas mediante Swift. Al usar Publish, se recomienda que cree su propio tema específico para el sitio web, que puede hacer un uso completo de sus propios metadatos personalizados y adaptarse por completo al diseño de su sitio web.</p><p>Los temas se definen utilizando el tipo <code>Theme</code>, que utiliza una implementación de<code> HTMLFactory</code> para crear todas las páginas HTML de un sitio web. A continuación, se muestra un extracto de cómo se vería la implementación del tema personalizado <code>.delicious</code> utilizado anteriormente:</p><pre><code class="language-swift">extension Theme where Site == DeliciousRecipes {
    static var delicious: Self {
        Theme(htmlFactory: DeliciousHTMLFactory())
    }
    private struct DeliciousHTMLFactory: HTMLFactory {
        ...
        func makeItemHTML(
            for item: Item&lt;DeliciousRecipes&gt;,
            context: PublishingContext&lt;DeliciousRecipes&gt;
        ) throws -&gt; HTML {
            HTML(
                .head(for: item, on: context.site),
                .body(
                    .ul(
                        .class("ingredients"),
                        .forEach(item.metadata.ingredients) {
                            .li(.text($0))
                        }
                    ),
                    .p(
                        "This will take around ",
                        "\(Int(item.metadata.preparationTime / 60)) ",
                        "minutes to prepare"
                    ),
                    .contentBody(item.body)
                )
            )
        }
        ...
    }
}
</code></pre><p>Arriba, podemos acceder tanto a las propiedades de elementos integradas como a las propiedades de metadatos personalizados que definimos anteriormente como parte de la estructura <code>ItemMetadata</code> de nuestro sitio web, todo ello de una manera que conserva la seguridad de tipo total.</p><h1>Creando Plugins</h1><p>Publish también admite complementos, que se pueden usar para compartir el código de configuración entre varios proyectos o para ampliar la funcionalidad integrada de Publish de varias formas. Al igual que los pasos de publicación, los complementos realizan su trabajo modificando el <code>PublishingContext</code> actual, por ejemplo, agregando archivos o carpetas, mutando el contenido existente del sitio web o agregando modificadores de análisis de Markdown.</p><p>A continuación, se muestra un ejemplo de un complemento que garantiza que todos los elementos de un sitio web tengan etiquetas:</p><pre><code class="language-swift">extension Plugin {
    static var ensureAllItemsAreTagged: Self {
        Plugin(name: "Ensure that all items are tagged") { context in
            let allItems = context.sections.flatMap { $0.items }
            for item in allItems {
                guard !item.tags.isEmpty else {
                    throw PublishingError(
                        path: item.path,
                        infoMessage: "Item has no tags"
                    )
                }
            }
        }
    }
}
</code></pre><p>Luego, los complementos se instalan agregando el paso <code>installPlugin</code> a cualquier canal de publicación:</p><pre><code class="language-swift">try DeliciousRecipes().publish(using: [
    ...
    .installPlugin(.ensureAllItemsAreTagged)
])
</code></pre><p>Para ver un ejemplo del mundo real de un plugin de Publish, consulte el [plugin de Splash] (https://github.com/johnsundell/splashpublishplugin), que facilita la integración del [resaltador de sintaxis de Splash] (https: / /github.com/johnsundell/splash) con Publicar.</p><h1>Requisitos del sistema</h1><p>Para poder utilizar Publish con éxito, asegúrese de que su sistema tenga <code>Swift versión 5.4 (o posterior) </code>instalada. Si está utilizando una Mac, asegúrese también de que <code>xcode-select</code> esté apuntando a una instalación de Xcode que incluya la versión requerida de Swift, y que esté ejecutando macOS Big Sur (11.0) o posterior.</p><p>Tenga en cuenta que Publish <strong>no</strong> admite oficialmente ningún tipo de software beta, incluidas las versiones beta de Xcode y macOS, o versiones inéditas de Swift.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://swiftzone.dev/posts/focusedBinding</guid><title>@FocusedBinding</title><description>El siguiente código apareció en el video en Apple WWDC20, presentando un nuevo envoltorio de atributo @FocusedBinding. Como todavía se encuentra en la fase de prueba, el código actual no se puede ejecutar correctamente. Apple rara vez divulga la información de @FocusedBinding y no hay información relevante en Internet. Por interés personal, realicé una simple investigación al respecto. Aunque @FocusedBinding se ejecuta en la versión actual de Xcode Versión 12.0 beta 2 (12A6163b), todavía hay muchos problemas, pero básicamente lo entiendo bien</description><link>https://swiftzone.dev/posts/focusedBinding</link><pubDate>Mon, 20 Jan 2020 13:04:00 -0500</pubDate><content:encoded><![CDATA[<blockquote><p>El siguiente código apareció en el video en Apple WWDC20, presentando un nuevo envoltorio de atributo @FocusedBinding. Como todavía se encuentra en la fase de prueba, el código actual no se puede ejecutar correctamente. Apple rara vez divulga la información de @FocusedBinding y no hay información relevante en Internet. Por interés personal, realicé una simple investigación al respecto. Aunque @FocusedBinding se ejecuta en la versión actual de Xcode Versión 12.0 beta 2 (12A6163b), todavía hay muchos problemas, pero básicamente lo entiendo bien</p></blockquote><pre><code class="language-swift">struct BookCommands: Commands {
 @FocusedBinding(\.selectedBook) private var selectedBook: Book?
  var body: some Commands {
    CommandMenu("Book") {
        Section {
            Button("Update Progress...", action: updateProgress)
                .keyboardShortcut("u")
            Button("Mark Completed", action: markCompleted)
                .keyboardShortcut("C")
        }
        .disabled(selectedBook == nil)
    }
  }

   private func updateProgress() {
       selectedBook?.updateProgress()
   }
   private func markCompleted() {
       selectedBook?.markCompleted()
   }
}
</code></pre><h2>Usar</h2><p><strong>Operaciones de intercambio, modificación y vinculación de datos entre cualquier vista (Vista).</strong></p><p>En SwiftUI1.0, podemos usar EnvironmentKey para pasar datos a la vista secundaria y PreferenceKey para pasar datos a la vista principal. Si queremos transferir datos entre dos vistas paralelas que no están en el mismo árbol de vistas, normalmente necesitamos usar Single of True o mediante NotificationCenter.</p><p>En SwiftUI2.0, Apple introdujo @FocusedBinding y @FocusedValue para resolver este problema. Al definir FocusedValueKey, podemos compartir, modificar y vincular datos directamente entre cualquier vista sin pasar por Single of truth.</p><p>En [SwiftUI2.0 —— Comandos (menú macOS)] (https://zhuanlan.zhihu.com/p/152127847) en este artículo, pasamos el método Único de verdad, a nivel de aplicación, para que los Commnads puedan compartir datos con otras vistas. A través de los ejemplos proporcionados por WWDC, podemos ver que Apple espera brindar una solución alternativa para completar las funciones mencionadas anteriormente. Del mismo modo, esta solución también nos permite intercambiar datos entre cualquier vista (ya sea en el mismo árbol o no).</p><h2>Instrucciones</h2><p>Su uso básico es muy similar al del entorno, primero debe definir la clave especificada</p><pre><code class="language-swift">struct FocusedMessageKey:FocusedValueKey{
    // A diferencia de EnvironmentKey, FocusedValueKey no tiene un valor predeterminado 
    // y debe ser un valor opcional. Para la siguiente demostración, aquí establecemos el 
    // tipo de datos en Binding &lt;String&gt;, que se puede establecer en cualquier tipo de valor de datos
    typealias Value = Binding&lt;String&gt;
}

extension FocusedValues{
    
    var message:Binding&lt;String&gt;?{
        get{self[FocusedMessageKey.self]}
        set{self[FocusedMessageKey.self] = newValue}
    }
}
</code></pre><p>Dado que se puede utilizar en cualquier vista, no es necesario inyectar datos. A diferencia de EnvironmentKey (solo válido en el árbol de vista inyectado actualmente), los datos son válidos en todo el dominio.</p><pre><code class="language-swift">struct ShowView:View{
    // El método de llamada es casi el mismo que @Environment, usar @FocusedValue o 
    // @FocusedBinding requiere un método de referencia diferente
    @FocusedValue(\.message) var focusedMessage
    //@FocusedBinding(\.message) var focusedMessage1
    var body: some View{
        VStack{
        Text("focused:\(focusedMessage?.wrappedValue ?? "")")
        //Text("focused:\(focusedMessage1 ?? "")")
        }
    }
}
</code></pre><p>Modifique los datos de FocusedValueKey en otra vista.</p><pre><code class="language-swift">struct InputView1:View{
    @State private var text = ""
    var body: some View{
        VStack{
        TextField("input1:",text:$text)
            .textFieldStyle(RoundedBorderTextFieldStyle())
            // Sincronizar mensaje y texto
            .focusedValue(\.message, $text)
        }
    }
}

</code></pre><p>La misma FocusedValueKey se puede modificar en varias vistas</p><pre><code class="language-swift">struct InputView2:View{
    @State private var text = ""
    var body:some View{
        TextField("input2:",text:$text)
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .focusedValue(\.message, $text)
    }
}
</code></pre><p>Finalmente ensamblados juntos</p><pre><code class="language-swift">struct RootView: View {
    var body: some View {
        VStack{
            // Las tres vistas están en una relación paralela Antes de utilizar Entorno o  
            // Preferencia, no se puede llevar a cabo la transmisión y el intercambio de 
            // datos entre estas tres vistas.
            InputView1()
            InputView2()
            ShowView()
        }
        .padding(.all, 20)
        .frame(maxWidth:.infinity, maxHeight: .infinity)
    }
}
</code></pre><!--<video src="http://cdn.fatbobman.com/focusebinding-video.mov" controls="controls"> ¡Su navegador no admite la reproducción de este video！</video>-->

Actualmente, el valor de FocusedValueKey no se puede obtener en iOS. El documento indica que es compatible con iOS, lo que debería resolverse en el futuro.

## ¿Cómo se usa, cómo se usa? ##

La introducción de FoccusedBinding mejora aún más la función de manipulación de datos en diferentes vistas de SwiftUI. Sin embargo, mi recomendación personal es no abusar de esta función.

Dado que podemos modificar el valor de la clave en cualquier vista, una vez que se abusa de ella, es probable que caiga en el dilema de que el código es difícil de administrar nuevamente.

Para algunas funciones son muy simples, no es necesario usar el código lógico MVVM, o Single de verdad está demasiado hinchado（[ObservableObject Research: quiero decir que no es fácil amarte](/posts/observableObject-study/)），Para los códigos que pueden causar problemas de respuesta de la aplicación, considere usar el esquema anterior.
]]></content:encoded></item></channel></rss>
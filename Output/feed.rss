<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>SwiftZone</title><description>Sharing my interests in Swift, iOS, Apple &amp; more</description><link>https://swiftzone.dev</link><language>es</language><lastBuildDate>Sat, 19 Aug 2023 11:22:43 -0400</lastBuildDate><pubDate>Sat, 19 Aug 2023 11:22:43 -0400</pubDate><ttl>250</ttl><atom:link href="https://swiftzone.dev/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="false">rss guid:</guid><title>前缀:Publish Framework尾缀:</title><description>Publish framework es un generador de sitios estáticos desarrollado por John Sundell y creado específicamente para desarrolladores de Swift. Permite crear sitios web completos con Swift y admite temas, plugins y toneladas de otras opciones de personalización potentes.</description><link>https://swiftzone.dev/posts/publish-framework</link><pubDate>Mon, 6 Dec 2021 07:00:00 -0500</pubDate><content:encoded><![CDATA[内容前缀:<p align="center" margin-top="10px">
    <img src="https://swiftzone.dev/images/blog/PublishLogo.png" width="400" max-width="90%" alt="Publish" />
</p><p>Publish framework es un generador de sitios estáticos desarrollado por John Sundell y creado específicamente para desarrolladores de Swift. Permite crear sitios web completos con Swift y admite temas, plugins y toneladas de otras opciones de personalización potentes.</p><p>Cuando se usa Publish, cada sitio web se define como un paquete Swift, que actúa como la configuración de cómo se debe generar e implementar el sitio web, todo utilizando código Swift nativo y de tipo seguro.</p><h1>Instalación</h1><p>Publish se distribuye utilizando Swift Package Manager. Para instalarlo en un proyecto, agréguelo como una dependencia dentro de su manifiesto Package.swift:</p><pre><code><span class="hljs-keyword">let</span> package = <span class="hljs-type">Package</span>(
    ...
    dependencies: [
        .<span class="hljs-call">package</span>(url: <span class="hljs-string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="hljs-string">"0.1.0"</span>)
    ],
    ...
)
</code></pre><p>Luego, importe Publish donde quiera usarlo:</p><pre><code><span class="hljs-keyword">import</span> Publish
</code></pre><p>Publish también incluye una herramienta de línea de comandos que facilita la configuración de nuevos proyectos de sitios web y la generación e implementación de los existentes. Para instalar esa herramienta de línea de comando, simplemente ejecute make dentro de una copia local del repositorio de publicación:</p><pre><code>$ git clone https://github.<span class="hljs-property">com</span>/<span class="hljs-type">JohnSundell</span>/<span class="hljs-type">Publish</span>.<span class="hljs-property">git</span>
$ cd <span class="hljs-type">Publish</span>
$ make
</code></pre><p>A continuación, ejecute <code>publish help</code> para obtener instrucciones sobre cómo utilizarla.<br></br></p><p>La herramienta de línea de comando Publicar también está disponible a través de Homebrew y se puede instalar usando el siguiente comando si tiene Homebrew instalado:</p><pre><code>brew install publish
</code></pre><h1>Inicio rápido</h1><p>Para comenzar rápidamente con Publish, instale la herramienta de línea de comando clonando primero este repositorio y luego ejecute <code>make</code> dentro de la carpeta clonada:</p><pre><code>$ git clone https://github.<span class="hljs-property">com</span>/<span class="hljs-type">JohnSundell</span>/<span class="hljs-type">Publish</span>.<span class="hljs-property">git</span>
$ cd <span class="hljs-type">Publish</span>
$ make
</code></pre><p><strong>*Nota</strong>: Si encuentra un error al ejecutar <code>make</code>, asegúrese de tener la ubicación de las herramientas de línea de comandos configurada en las preferencias de Xcode. Está en Preferencias&gt; Ubicaciones&gt; Ubicaciones&gt; Herramientas de línea de comandos. El menú desplegable estará en blanco si aún no se ha configurado._</p><p>Luego, cree una nueva carpeta para su nuevo proyecto de sitio web y simplemente ejecute <code>publish new</code> dentro de ella para comenzar:</p><pre><code>$ mkdir <span class="hljs-type">MyWebsite</span>
$ cd <span class="hljs-type">MyWebsite</span>
$ publish new
</code></pre><p>Finalmente, ejecute <code>open Package.swift</code> para abrir el proyecto en Xcode y comenzar a construir su nuevo sitio web.</p><h1>Server</h1><p>Para iniciar el servidor de desarrollo ejecute en la raíz del proyecto <code>publish run</code> y le mostrara un mensaje en consola con la url a consultar.</p><h1>Comience de manera simple y personalice cuando sea necesario</h1><p>Cada sitio web creado con Publish puede decidir libremente qué tipo de secciones y metadatos desea admitir. Arriba, agregamos tres secciones: Recetas, Vínculos y Acerca de, que luego pueden contener cualquier cantidad de elementos. También hemos agregado soporte para nuestros propios metadatos de elementos específicos del sitio a través del tipo ItemMetadata, que podremos usar de manera totalmente segura durante todo el proceso de publicación.</p><pre><code><span class="hljs-keyword">struct</span> DeliciousRecipes: <span class="hljs-type">Website</span> {
    <span class="hljs-keyword">enum</span> SectionID: <span class="hljs-type">String</span>, <span class="hljs-type">WebsiteSectionID</span> {
        <span class="hljs-keyword">case</span> recipes
        <span class="hljs-keyword">case</span> links
        <span class="hljs-keyword">case</span> about
    }

    <span class="hljs-keyword">struct</span> ItemMetadata: <span class="hljs-type">WebsiteItemMetadata</span> {
        <span class="hljs-keyword">var</span> ingredients: [<span class="hljs-type">String</span>]
        <span class="hljs-keyword">var</span> preparationTime: <span class="hljs-type">TimeInterval</span>
    }

    <span class="hljs-keyword">var</span> url = <span class="hljs-type">URL</span>(string: <span class="hljs-string">"https://cooking-with-john.com"</span>)!
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Delicious Recipes"</span>
    <span class="hljs-keyword">var</span> description = <span class="hljs-string">"Many very delicious recipes."</span>
    <span class="hljs-keyword">var</span> language: <span class="hljs-type">Language</span> { .<span class="hljs-dotAccess">english</span> }
    <span class="hljs-keyword">var</span> imagePath: <span class="hljs-type">Path</span>? { <span class="hljs-string">"images/logo.png"</span> }
}
</code></pre><p>Si bien Publish ofrece una API realmente poderosa que permite personalizar y ajustar casi todos los aspectos del proceso de generación de sitios web, también incluye un conjunto de API de conveniencia que tiene como objetivo hacer que comenzar sea lo más rápido y fácil posible.</p><p>Para comenzar a generar el sitio web de Delicious Recipes que definimos anteriormente, todo lo que necesitamos es una sola línea de código, que le dice a Publish qué tema usar para generar el HTML de nuestro sitio web:</p><pre><code><span class="hljs-keyword">try</span> <span class="hljs-type">DeliciousRecipes</span>().<span class="hljs-call">publish</span>(withTheme: .<span class="hljs-dotAccess">foundation</span>)
</code></pre><p><em>La llamada anterior no solo representa el HTML de nuestro sitio web, sino que también genera una fuente RSS, un mapa del sitio y más.</em></p><p>Anteriormente, usamos el tema básico integrado de Publish, que es un tema muy básico que se proporciona principalmente como punto de partida y como ejemplo de cómo se pueden crear los temas de Publish. Por supuesto, podemos reemplazar ese tema en cualquier momento por uno propio y personalizado, que puede incluir cualquier tipo de HTML y recursos que queramos.</p><p>De forma predeterminada, Publish generará el contenido de un sitio web en función de los archivos Markdown colocados dentro de la carpeta <code>Content</code> de ese proyecto, pero también se puede agregar mediante programación cualquier número de elementos de contenido y páginas personalizadas.</p><p><strong>Publish admite tres tipos de contenido:</strong></p><p><strong>Sections</strong>, que se crean en función de los miembros de la enumeración <code>SectionID</code> de cada sitio web. Cada sección tiene su propia página HTML y también puede actuar como un contenedor para una lista de <strong>Items</strong>, que representan las páginas HTML anidadas dentro de esa sección. Finalmente, <strong>Pages</strong> proporciona una forma de crear páginas personalizadas de formato libre que se pueden colocar en cualquier tipo de jerarquía de carpetas.</p><p>Cada <code>Section</code>, <code>Items</code> y <code>Page</code> puede definir su propio conjunto de Contenido, que puede variar desde texto (como títulos y descripciones) hasta HTML, audio, video y varios tipos de metadatos.</p><p>A continuación, le mostramos cómo podríamos extender nuestra llamada básica <code>publish()</code> desde antes para inyectar nuestra propia canalización de publicación personalizada, lo que nos permite definir nuevos elementos, modificar secciones y mucho más:</p><pre><code><span class="hljs-keyword">try</span> <span class="hljs-type">DeliciousRecipes</span>().<span class="hljs-call">publish</span>(
    withTheme: .<span class="hljs-dotAccess">foundation</span>,
    additionalSteps: [
        <span class="hljs-comment">// Agrega un item mediante código</span>
        .<span class="hljs-call">addItem</span>(<span class="hljs-type">Item</span>(
            path: <span class="hljs-string">"my-favorite-recipe"</span>,
            sectionID: .<span class="hljs-dotAccess">recipes</span>,
            metadata: <span class="hljs-type">DeliciousRecipes</span>.<span class="hljs-type">ItemMetadata</span>(
                ingredients: [<span class="hljs-string">"Chocolate"</span>, <span class="hljs-string">"Coffee"</span>, <span class="hljs-string">"Flour"</span>],
                preparationTime: <span class="hljs-number">10</span> * <span class="hljs-number">60</span>
            ),
            tags: [<span class="hljs-string">"favorite"</span>, <span class="hljs-string">"featured"</span>],
            content: <span class="hljs-type">Content</span>(
                title: <span class="hljs-string">"Check out my favorite recipe!"</span>
            )
        )),
        <span class="hljs-comment">// Agrega titulos por defecto a todas las secciones</span>
        .<span class="hljs-call">step</span>(named: <span class="hljs-string">"Default section titles"</span>) { context <span class="hljs-keyword">in</span>
            context.<span class="hljs-call">mutateAllSections</span> { section <span class="hljs-keyword">in
                guard</span> section.<span class="hljs-property">title</span>.<span class="hljs-property">isEmpty</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
                
                <span class="hljs-keyword">switch</span> section.<span class="hljs-property">id</span> {
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">recipes</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"My recipes"</span>
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">links</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"External links"</span>
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">about</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"About this site"</span>
                }
            }
        }
    ]
)
</code></pre><p>Por supuesto, definir todo el código de un programa en un solo lugar rara vez es una buena idea, por lo que se recomienda dividir las diversas operaciones de generación de un sitio web en pasos claramente separados, que se pueden definir extendiendo el tipo <code>PublishingStep</code> con propiedades estáticas o métodos, como este:</p><pre><code><span class="hljs-keyword">extension</span> <span class="hljs-type">PublishingStep</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Site</span> == <span class="hljs-type">DeliciousRecipes</span> {
    <span class="hljs-keyword">static func</span> addDefaultSectionTitles() -&gt; <span class="hljs-type">Self</span> {
        .<span class="hljs-call">step</span>(named: <span class="hljs-string">"Titulo de secciones por defecto"</span>) { context <span class="hljs-keyword">in</span>
            context.<span class="hljs-call">mutateAllSections</span> { section <span class="hljs-keyword">in
                guard</span> section.<span class="hljs-property">title</span>.<span class="hljs-property">isEmpty</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> }
                <span class="hljs-keyword">switch</span> section.<span class="hljs-property">id</span> {
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">recipes</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"My recipes"</span>
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">links</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"External links"</span>
                <span class="hljs-keyword">case</span> .<span class="hljs-dotAccess">about</span>:
                    section.<span class="hljs-property">title</span> = <span class="hljs-string">"About this site"</span>
                }
            }
        }
    }
}
</code></pre><p><em>A cada paso de publicación se le pasa una instancia de <code>PublishingContext</code>, que puede usar para mutar el contexto actual en el que se publica el sitio web, incluidos sus archivos, carpetas y contenido.</em></p><p>Con el patrón anterior, podemos implementar cualquier número de pasos de publicación personalizados que se ajusten perfectamente a todos los pasos predeterminados con los que se envía Publish. Esto nos permite construir pipelines realmente poderosos en los que cada paso realiza una sola parte del proceso de generación:</p><pre><code><span class="hljs-keyword">try</span> <span class="hljs-type">DeliciousRecipes</span>().<span class="hljs-call">publish</span>(using: [
    .<span class="hljs-call">addMarkdownFiles</span>(),
    .<span class="hljs-call">copyResources</span>(),
    .<span class="hljs-call">addFavoriteItems</span>(),
    .<span class="hljs-call">addDefaultSectionTitles</span>(),
    .<span class="hljs-call">generateHTML</span>(withTheme: .<span class="hljs-dotAccess">delicious</span>),
    .<span class="hljs-call">generateRSSFeed</span>(including: [.<span class="hljs-dotAccess">recipes</span>]),
    .<span class="hljs-call">generateSiteMap</span>()
])
</code></pre><p><em>Arriba, estamos construyendo una canalización de publicación completamente personalizada llamando a la API <code>publish(using:)</code>.</em></p><p>Para obtener más información sobre los pasos de publicación integrados de Publish,<a href="https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/PublishingStep.swift">mira este archivo</a>.</p><h1>Construyendo un tema HTML</h1><p>Publish utiliza [Plot] (https://github.com/johnsundell/plot) como motor de creación de temas HTML, que permite definir páginas HTML completas mediante Swift. Al usar Publish, se recomienda que cree su propio tema específico para el sitio web, que puede hacer un uso completo de sus propios metadatos personalizados y adaptarse por completo al diseño de su sitio web.</p><p>Los temas se definen utilizando el tipo <code>Theme</code>, que utiliza una implementación de<code> HTMLFactory</code> para crear todas las páginas HTML de un sitio web. A continuación, se muestra un extracto de cómo se vería la implementación del tema personalizado <code>.delicious</code> utilizado anteriormente:</p><pre><code><span class="hljs-keyword">extension</span> <span class="hljs-type">Theme</span> <span class="hljs-keyword">where</span> <span class="hljs-type">Site</span> == <span class="hljs-type">DeliciousRecipes</span> {
    <span class="hljs-keyword">static var</span> delicious: <span class="hljs-type">Self</span> {
        <span class="hljs-type">Theme</span>(htmlFactory: <span class="hljs-type">DeliciousHTMLFactory</span>())
    }
    <span class="hljs-keyword">private struct</span> DeliciousHTMLFactory: <span class="hljs-type">HTMLFactory</span> {
        ...
        <span class="hljs-keyword">func</span> makeItemHTML(
            for item: <span class="hljs-type">Item</span>&lt;<span class="hljs-type">DeliciousRecipes</span>&gt;,
            context: <span class="hljs-type">PublishingContext</span>&lt;<span class="hljs-type">DeliciousRecipes</span>&gt;
        ) <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">HTML</span> {
            <span class="hljs-type">HTML</span>(
                .<span class="hljs-call">head</span>(for: item, on: context.<span class="hljs-property">site</span>),
                .<span class="hljs-call">body</span>(
                    .<span class="hljs-call">ul</span>(
                        .<span class="hljs-call">class</span>(<span class="hljs-string">"ingredients"</span>),
                        .<span class="hljs-call">forEach</span>(item.<span class="hljs-property">metadata</span>.<span class="hljs-property">ingredients</span>) {
                            .<span class="hljs-call">li</span>(.<span class="hljs-call">text</span>($0))
                        }
                    ),
                    .<span class="hljs-call">p</span>(
                        <span class="hljs-string">"This will take around "</span>,
                        <span class="hljs-string">"</span>\(<span class="hljs-type">Int</span>(item.<span class="hljs-property">metadata</span>.<span class="hljs-property">preparationTime</span> / <span class="hljs-number">60</span>)) <span class="hljs-string">"</span>,
                        <span class="hljs-string">"minutes to prepare"</span>
                    ),
                    .<span class="hljs-call">contentBody</span>(item.<span class="hljs-property">body</span>)
                )
            )
        }
        ...
    }
}
</code></pre><p>Arriba, podemos acceder tanto a las propiedades de elementos integradas como a las propiedades de metadatos personalizados que definimos anteriormente como parte de la estructura <code>ItemMetadata</code> de nuestro sitio web, todo ello de una manera que conserva la seguridad de tipo total.</p><h1>Creando Plugins</h1><p>Publish también admite complementos, que se pueden usar para compartir el código de configuración entre varios proyectos o para ampliar la funcionalidad integrada de Publish de varias formas. Al igual que los pasos de publicación, los complementos realizan su trabajo modificando el <code>PublishingContext</code> actual, por ejemplo, agregando archivos o carpetas, mutando el contenido existente del sitio web o agregando modificadores de análisis de Markdown.</p><p>A continuación, se muestra un ejemplo de un complemento que garantiza que todos los elementos de un sitio web tengan etiquetas:</p><pre><code><span class="hljs-keyword">extension</span> <span class="hljs-type">Plugin</span> {
    <span class="hljs-keyword">static var</span> ensureAllItemsAreTagged: <span class="hljs-type">Self</span> {
        <span class="hljs-type">Plugin</span>(name: <span class="hljs-string">"Ensure that all items are tagged"</span>) { context <span class="hljs-keyword">in
            let</span> allItems = context.<span class="hljs-property">sections</span>.<span class="hljs-call">flatMap</span> { $0.<span class="hljs-property">items</span> }
            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> allItems {
                <span class="hljs-keyword">guard</span> !item.<span class="hljs-property">tags</span>.<span class="hljs-property">isEmpty</span> <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">throw</span> <span class="hljs-type">PublishingError</span>(
                        path: item.<span class="hljs-property">path</span>,
                        infoMessage: <span class="hljs-string">"Item has no tags"</span>
                    )
                }
            }
        }
    }
}
</code></pre><p>Luego, los complementos se instalan agregando el paso <code>installPlugin</code> a cualquier canal de publicación:</p><pre><code><span class="hljs-keyword">try</span> <span class="hljs-type">DeliciousRecipes</span>().<span class="hljs-call">publish</span>(using: [
    ...
    .<span class="hljs-call">installPlugin</span>(.<span class="hljs-dotAccess">ensureAllItemsAreTagged</span>)
])
</code></pre><p>Para ver un ejemplo del mundo real de un plugin de Publish, consulte el [plugin de Splash] (https://github.com/johnsundell/splashpublishplugin), que facilita la integración del [resaltador de sintaxis de Splash] (https: / /github.com/johnsundell/splash) con Publicar.</p><h1>Requisitos del sistema</h1><p>Para poder utilizar Publish con éxito, asegúrese de que su sistema tenga <code>Swift versión 5.4 (o posterior) </code>instalada. Si está utilizando una Mac, asegúrese también de que <code>xcode-select</code> esté apuntando a una instalación de Xcode que incluya la versión requerida de Swift, y que esté ejecutando macOS Big Sur (11.0) o posterior.</p><p>Tenga en cuenta que Publish <strong>no</strong> admite oficialmente ningún tipo de software beta, incluidas las versiones beta de Xcode y macOS, o versiones inéditas de Swift.</p>内容尾缀]]></content:encoded></item><item><guid isPermaLink="false">rss guid:</guid><title>前缀:@FocusedBinding尾缀:</title><description>El siguiente código apareció en el video en Apple WWDC20, presentando un nuevo envoltorio de atributo @FocusedBinding. Como todavía se encuentra en la fase de prueba, el código actual no se puede ejecutar correctamente. Apple rara vez divulga la información de @FocusedBinding y no hay información relevante en Internet. Por interés personal, realicé una simple investigación al respecto. Aunque @FocusedBinding se ejecuta en la versión actual de Xcode Versión 12.0 beta 2 (12A6163b), todavía hay muchos problemas, pero básicamente lo entiendo bien</description><link>https://swiftzone.dev/posts/focusedBinding</link><pubDate>Mon, 20 Jan 2020 13:04:00 -0500</pubDate><content:encoded><![CDATA[内容前缀:<blockquote><p>El siguiente código apareció en el video en Apple WWDC20, presentando un nuevo envoltorio de atributo @FocusedBinding. Como todavía se encuentra en la fase de prueba, el código actual no se puede ejecutar correctamente. Apple rara vez divulga la información de @FocusedBinding y no hay información relevante en Internet. Por interés personal, realicé una simple investigación al respecto. Aunque @FocusedBinding se ejecuta en la versión actual de Xcode Versión 12.0 beta 2 (12A6163b), todavía hay muchos problemas, pero básicamente lo entiendo bien</p></blockquote><pre><code><span class="hljs-keyword">struct</span> BookCommands: <span class="hljs-type">Commands</span> {
 <span class="hljs-keyword">@FocusedBinding</span>(\.<span class="hljs-property">selectedBook</span>) <span class="hljs-keyword">private var</span> selectedBook: <span class="hljs-type">Book</span>?
  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">Commands</span> {
    <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Book"</span>) {
        <span class="hljs-type">Section</span> {
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Update Progress..."</span>, action: updateProgress)
                .<span class="hljs-call">keyboardShortcut</span>(<span class="hljs-string">"u"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Mark Completed"</span>, action: markCompleted)
                .<span class="hljs-call">keyboardShortcut</span>(<span class="hljs-string">"C"</span>)
        }
        .<span class="hljs-call">disabled</span>(selectedBook == <span class="hljs-keyword">nil</span>)
    }
  }

   <span class="hljs-keyword">private func</span> updateProgress() {
       selectedBook?.<span class="hljs-call">updateProgress</span>()
   }
   <span class="hljs-keyword">private func</span> markCompleted() {
       selectedBook?.<span class="hljs-call">markCompleted</span>()
   }
}
</code></pre><h2>Usar</h2><p><strong>Operaciones de intercambio, modificación y vinculación de datos entre cualquier vista (Vista).</strong></p><p>En SwiftUI1.0, podemos usar EnvironmentKey para pasar datos a la vista secundaria y PreferenceKey para pasar datos a la vista principal. Si queremos transferir datos entre dos vistas paralelas que no están en el mismo árbol de vistas, normalmente necesitamos usar Single of True o mediante NotificationCenter.</p><p>En SwiftUI2.0, Apple introdujo @FocusedBinding y @FocusedValue para resolver este problema. Al definir FocusedValueKey, podemos compartir, modificar y vincular datos directamente entre cualquier vista sin pasar por Single of truth.</p><p>En [SwiftUI2.0 —— Comandos (menú macOS)] (https://zhuanlan.zhihu.com/p/152127847) en este artículo, pasamos el método Único de verdad, a nivel de aplicación, para que los Commnads puedan compartir datos con otras vistas. A través de los ejemplos proporcionados por WWDC, podemos ver que Apple espera brindar una solución alternativa para completar las funciones mencionadas anteriormente. Del mismo modo, esta solución también nos permite intercambiar datos entre cualquier vista (ya sea en el mismo árbol o no).</p><h2>Instrucciones</h2><p>Su uso básico es muy similar al del entorno, primero debe definir la clave especificada</p><pre><code><span class="hljs-keyword">struct</span> FocusedMessageKey:<span class="hljs-type">FocusedValueKey</span>{
    <span class="hljs-comment">// A diferencia de EnvironmentKey, FocusedValueKey no tiene un valor predeterminado 
    // y debe ser un valor opcional. Para la siguiente demostración, aquí establecemos el 
    // tipo de datos en Binding &lt;String&gt;, que se puede establecer en cualquier tipo de valor de datos</span>
    <span class="hljs-keyword">typealias</span> Value = <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;
}

<span class="hljs-keyword">extension</span> <span class="hljs-type">FocusedValues</span>{
    
    <span class="hljs-keyword">var</span> message:<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;?{
        <span class="hljs-keyword">get</span>{<span class="hljs-keyword">self</span>[<span class="hljs-type">FocusedMessageKey</span>.<span class="hljs-keyword">self</span>]}
        <span class="hljs-keyword">set</span>{<span class="hljs-keyword">self</span>[<span class="hljs-type">FocusedMessageKey</span>.<span class="hljs-keyword">self</span>] = newValue}
    }
}
</code></pre><p>Dado que se puede utilizar en cualquier vista, no es necesario inyectar datos. A diferencia de EnvironmentKey (solo válido en el árbol de vista inyectado actualmente), los datos son válidos en todo el dominio.</p><pre><code><span class="hljs-keyword">struct</span> ShowView:<span class="hljs-type">View</span>{
    <span class="hljs-comment">// El método de llamada es casi el mismo que @Environment, usar @FocusedValue o 
    // @FocusedBinding requiere un método de referencia diferente</span>
    <span class="hljs-keyword">@FocusedValue</span>(\.<span class="hljs-property">message</span>) <span class="hljs-keyword">var</span> focusedMessage
    <span class="hljs-comment">//@FocusedBinding(\.message) var focusedMessage1</span>
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"focused:</span>\(focusedMessage?.<span class="hljs-property">wrappedValue</span> ?? <span class="hljs-string">""</span>)<span class="hljs-string">"</span>)
        <span class="hljs-comment">//Text("focused:\(focusedMessage1 ?? "")")</span>
        }
    }
}
</code></pre><p>Modifique los datos de FocusedValueKey en otra vista.</p><pre><code><span class="hljs-keyword">struct</span> InputView1:<span class="hljs-type">View</span>{
    <span class="hljs-keyword">@State private var</span> text = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">TextField</span>(<span class="hljs-string">"input1:"</span>,text:<span class="hljs-property">$text</span>)
            .<span class="hljs-call">textFieldStyle</span>(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())
            <span class="hljs-comment">// Sincronizar mensaje y texto</span>
            .<span class="hljs-call">focusedValue</span>(\.<span class="hljs-property">message</span>, <span class="hljs-property">$text</span>)
        }
    }
}

</code></pre><p>La misma FocusedValueKey se puede modificar en varias vistas</p><pre><code><span class="hljs-keyword">struct</span> InputView2:<span class="hljs-type">View</span>{
    <span class="hljs-keyword">@State private var</span> text = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body:<span class="hljs-keyword">some</span> <span class="hljs-type">View</span>{
        <span class="hljs-type">TextField</span>(<span class="hljs-string">"input2:"</span>,text:<span class="hljs-property">$text</span>)
            .<span class="hljs-call">textFieldStyle</span>(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())
            .<span class="hljs-call">focusedValue</span>(\.<span class="hljs-property">message</span>, <span class="hljs-property">$text</span>)
    }
}
</code></pre><p>Finalmente ensamblados juntos</p><pre><code><span class="hljs-keyword">struct</span> RootView: <span class="hljs-type">View</span> {
    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-comment">// Las tres vistas están en una relación paralela Antes de utilizar Entorno o  
            // Preferencia, no se puede llevar a cabo la transmisión y el intercambio de 
            // datos entre estas tres vistas.</span>
            <span class="hljs-type">InputView1</span>()
            <span class="hljs-type">InputView2</span>()
            <span class="hljs-type">ShowView</span>()
        }
        .<span class="hljs-call">padding</span>(.<span class="hljs-dotAccess">all</span>, <span class="hljs-number">20</span>)
        .<span class="hljs-call">frame</span>(maxWidth:.infinity, maxHeight: .<span class="hljs-dotAccess">infinity</span>)
    }
}
</code></pre><!--<video src="http://cdn.fatbobman.com/focusebinding-video.mov" controls="controls"> ¡Su navegador no admite la reproducción de este video！</video>-->

Actualmente, el valor de FocusedValueKey no se puede obtener en iOS. El documento indica que es compatible con iOS, lo que debería resolverse en el futuro.

## ¿Cómo se usa, cómo se usa? ##

La introducción de FoccusedBinding mejora aún más la función de manipulación de datos en diferentes vistas de SwiftUI. Sin embargo, mi recomendación personal es no abusar de esta función.

Dado que podemos modificar el valor de la clave en cualquier vista, una vez que se abusa de ella, es probable que caiga en el dilema de que el código es difícil de administrar nuevamente.

Para algunas funciones son muy simples, no es necesario usar el código lógico MVVM, o Single de verdad está demasiado hinchado（[ObservableObject Research: quiero decir que no es fácil amarte](/posts/observableObject-study/)），Para los códigos que pueden causar problemas de respuesta de la aplicación, considere usar el esquema anterior.
内容尾缀]]></content:encoded></item></channel></rss>
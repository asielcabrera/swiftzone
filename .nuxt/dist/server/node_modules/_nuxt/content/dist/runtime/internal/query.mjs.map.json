{"file":"query.mjs","mappings":"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","names":[],"sources":["../../../../../../../../../node_modules/@nuxt/content/dist/runtime/internal/query.js"],"sourcesContent":["import { withoutTrailingSlash } from \"ufo\";\nimport { tables } from \"#content/manifest\";\nconst buildGroup = (group, type) => {\n  const conditions = group._conditions;\n  return conditions.length > 0 ? `(${conditions.join(` ${type} `)})` : \"\";\n};\nexport const collectionQueryGroup = (collection) => {\n  const conditions = [];\n  const query = {\n    // @ts-expect-error -- internal\n    _conditions: conditions,\n    where(field, operator, value) {\n      let condition;\n      switch (operator.toUpperCase()) {\n        case \"IN\":\n        case \"NOT IN\":\n          if (Array.isArray(value)) {\n            const values = value.map((val) => singleQuote(val)).join(\", \");\n            condition = `\"${String(field)}\" ${operator.toUpperCase()} (${values})`;\n          } else {\n            throw new TypeError(`Value for ${operator} must be an array`);\n          }\n          break;\n        case \"BETWEEN\":\n        case \"NOT BETWEEN\":\n          if (Array.isArray(value) && value.length === 2) {\n            condition = `\"${String(field)}\" ${operator.toUpperCase()} ${singleQuote(value[0])} AND ${singleQuote(value[1])}`;\n          } else {\n            throw new Error(`Value for ${operator} must be an array with two elements`);\n          }\n          break;\n        case \"IS NULL\":\n        case \"IS NOT NULL\":\n          condition = `\"${String(field)}\" ${operator.toUpperCase()}`;\n          break;\n        case \"LIKE\":\n        case \"NOT LIKE\":\n          condition = `\"${String(field)}\" ${operator.toUpperCase()} ${singleQuote(value)}`;\n          break;\n        default:\n          condition = `\"${String(field)}\" ${operator} ${singleQuote(typeof value === \"boolean\" ? Number(value) : value)}`;\n      }\n      conditions.push(`${condition}`);\n      return query;\n    },\n    andWhere(groupFactory) {\n      const group = groupFactory(collectionQueryGroup(collection));\n      conditions.push(buildGroup(group, \"AND\"));\n      return query;\n    },\n    orWhere(groupFactory) {\n      const group = groupFactory(collectionQueryGroup(collection));\n      conditions.push(buildGroup(group, \"OR\"));\n      return query;\n    }\n  };\n  return query;\n};\nexport const collectionQueryBuilder = (collection, fetch) => {\n  const params = {\n    conditions: [],\n    selectedFields: [],\n    offset: 0,\n    limit: 0,\n    orderBy: [],\n    // Count query\n    count: {\n      field: \"\",\n      distinct: false\n    }\n  };\n  const query = {\n    // @ts-expect-error -- internal\n    __params: params,\n    andWhere(groupFactory) {\n      const group = groupFactory(collectionQueryGroup(collection));\n      params.conditions.push(buildGroup(group, \"AND\"));\n      return query;\n    },\n    orWhere(groupFactory) {\n      const group = groupFactory(collectionQueryGroup(collection));\n      params.conditions.push(buildGroup(group, \"OR\"));\n      return query;\n    },\n    path(path) {\n      return query.where(\"path\", \"=\", withoutTrailingSlash(path));\n    },\n    skip(skip) {\n      params.offset = skip;\n      return query;\n    },\n    where(field, operator, value) {\n      query.andWhere((group) => group.where(String(field), operator, value));\n      return query;\n    },\n    limit(limit) {\n      params.limit = limit;\n      return query;\n    },\n    select(...fields) {\n      if (fields.length) {\n        params.selectedFields.push(...fields);\n      }\n      return query;\n    },\n    order(field, direction) {\n      params.orderBy.push(`\"${String(field)}\" ${direction}`);\n      return query;\n    },\n    async all() {\n      return fetch(collection, buildQuery()).then((res) => res || []);\n    },\n    async first() {\n      return fetch(collection, buildQuery({ limit: 1 })).then((res) => res[0] || null);\n    },\n    async count(field = \"*\", distinct = false) {\n      return fetch(collection, buildQuery({\n        count: { field: String(field), distinct }\n      })).then((m) => m[0].count);\n    }\n  };\n  function buildQuery(opts = {}) {\n    let query2 = \"SELECT \";\n    if (opts?.count) {\n      query2 += `COUNT(${opts.count.distinct ? \"DISTINCT \" : \"\"}${opts.count.field}) as count`;\n    } else {\n      const fields = Array.from(new Set(params.selectedFields));\n      query2 += fields.length > 0 ? fields.map((f) => `\"${String(f)}\"`).join(\", \") : \"*\";\n    }\n    query2 += ` FROM ${tables[String(collection)]}`;\n    if (params.conditions.length > 0) {\n      query2 += ` WHERE ${params.conditions.join(\" AND \")}`;\n    }\n    if (params.orderBy.length > 0) {\n      query2 += ` ORDER BY ${params.orderBy.join(\", \")}`;\n    } else {\n      query2 += ` ORDER BY stem ASC`;\n    }\n    const limit = opts?.limit || params.limit;\n    if (limit > 0) {\n      if (params.offset > 0) {\n        query2 += ` LIMIT ${limit} OFFSET ${params.offset}`;\n      } else {\n        query2 += ` LIMIT ${limit}`;\n      }\n    }\n    return query2;\n  }\n  return query;\n};\nfunction singleQuote(value) {\n  return `'${String(value).replace(/'/g, \"''\")}'`;\n}\n"],"version":3}